This patch was taken from gitweb.openembedded.org (Author: Michael 'mickey' Lauer) and
enables the cross compilation of the ctypes module.

--- setup.py	2006-08-10 01:42:18.000000000 +0200
+++ setup.py.new	2007-11-21 18:00:43.000000000 +0100
@@ -1321,16 +1329,16 @@
                                          ffi_configfile):
                 from distutils.dir_util import mkpath
                 mkpath(ffi_builddir)
-                config_args = []
+                config_args = ['--host=%s' % os.environ["CHOST"], ]
 
                 # Pass empty CFLAGS because we'll just append the resulting
                 # CFLAGS to Python's; -g or -O2 is to be avoided.
-                cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
-                      % (ffi_builddir, ffi_srcdir, " ".join(config_args))
+                cmd = "(cd %s && autoconf -W cross) && (cd %s && env CFLAGS='' '%s/configure' %s)" \
+                      % (ffi_srcdir, ffi_builddir, ffi_srcdir, " ".join(config_args))
 
                 res = os.system(cmd)
                 if res or not os.path.exists(ffi_configfile):
-                    print "Failed to configure _ctypes module"
+                    print "Failed to configure _ctypes module, ret %d or missing %s"% (res, ffi_configfile, )
                     return False
 
             fficonfig = {}
--- Modules/_ctypes/malloc_closure.c	2006-06-12 22:56:48.000000000 +0200
+++ Modules/_ctypes/malloc_closure.c.new	2007-11-22 10:30:17.000000000 +0100
@@ -27,7 +27,9 @@
 /******************************************************************/
 
 typedef union _tagITEM {
+#if FFI_CLOSURES
 	ffi_closure closure;
+#endif
 	union _tagITEM *next;
 } ITEM;
 
--- Modules/_ctypes/ctypes.h	2009-04-19 18:35:49.000000000 +0000
+++ Modules/_ctypes/ctypes.h.new	2009-04-19 18:36:34.000000000 +0000
@@ -69,7 +69,9 @@
 
 typedef struct {
 	PyObject_VAR_HEAD
+#if FFI_CLOSURES
 	ffi_closure *pcl; /* the C callable */
+#endif
 	ffi_cif cif;
 	PyObject *converters;
 	PyObject *callable;
--- Modules/_ctypes/callbacks.c	2009-07-02 14:23:24.000000000 +0200
+++ Modules/_ctypes/callbacks.c.new	2009-07-02 14:21:05.000000000 +0200
@@ -20,8 +20,10 @@
 	Py_XDECREF(self->converters);
 	Py_XDECREF(self->callable);
 	Py_XDECREF(self->restype);
+#if FFI_CLOSURES
 	if (self->pcl)
 		FreeClosure(self->pcl);
+#endif
 	PyObject_Del(self);
 }
 
@@ -336,7 +338,9 @@
 		return NULL;
 	}
 
+#if FFI_CLOSURES
 	p->pcl = NULL;
+#endif
 	memset(&p->cif, 0, sizeof(p->cif));
 	p->converters = NULL;
 	p->callable = NULL;
@@ -365,12 +369,13 @@
 
 	assert(CThunk_CheckExact(p));
 
+#if FFI_CLOSURES
 	p->pcl = MallocClosure();
 	if (p->pcl == NULL) {
 		PyErr_NoMemory();
 		goto error;
 	}
-
+#endif
 	for (i = 0; i < nArgs; ++i) {
 		PyObject *cnv = PySequence_GetItem(converters, i);
 		if (cnv == NULL)
@@ -409,13 +414,14 @@
 			     "ffi_prep_cif failed with %d", result);
 		goto error;
 	}
+#if FFI_CLOSURES
 	result = ffi_prep_closure(p->pcl, &p->cif, closure_fcn, p);
 	if (result != FFI_OK) {
 		PyErr_Format(PyExc_RuntimeError,
 			     "ffi_prep_closure failed with %d", result);
 		goto error;
 	}
-
+#endif
 	Py_INCREF(converters);
 	p->converters = converters;
 	Py_INCREF(callable);
--- Modules/_ctypes/_ctypes.c	2008-10-18 23:33:44.000000000 +0200
+++ Modules/_ctypes/_ctypes.c.new	2009-07-02 14:28:31.000000000 +0200
@@ -2952,7 +2952,11 @@
 	self->callable = callable;
 
 	self->thunk = thunk;
+#if FFI_CLOSURES
 	*(void **)self->b_ptr = (void *)thunk->pcl;
+#else
+	*(void **)self->b_ptr = NULL;
+#endif
 	
 	Py_INCREF((PyObject *)thunk); /* for KeepRef */
 	if (-1 == KeepRef((CDataObject *)self, 0, (PyObject *)thunk)) {
