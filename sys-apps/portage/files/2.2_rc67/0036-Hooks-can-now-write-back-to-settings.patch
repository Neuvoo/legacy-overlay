From f03be476f8e4e0be33802b957676177f353d63a4 Mon Sep 17 00:00:00 2001
From: Jacob Godserv <jacobgodserv@gmail.com>
Date: Sat, 5 Jun 2010 13:49:49 -0400
Subject: [PATCH 36/52] Hooks can now write back to settings

---
 bin/hooks.sh                                  |   49 +++++++++++++++++
 pym/portage/const.py                          |    1 +
 pym/portage/hooks.py                          |   72 ++++++++++++-------------
 pym/portage/tests/hooks/test_HookDirectory.py |    4 +-
 4 files changed, 87 insertions(+), 39 deletions(-)
 create mode 100755 bin/hooks.sh

diff --git a/bin/hooks.sh b/bin/hooks.sh
new file mode 100755
index 0000000..859c6a1
--- /dev/null
+++ b/bin/hooks.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+# Copyright 1999-2010 Gentoo Foundation
+# Distributed under the terms of the GNU General Public License v2
+
+function hooksave () {
+	local unsecure_varname="$1"
+	local varname="$(basename ${unsecure_varname})"
+	
+	if [[ "${unsecure_varname}" != "${varname}" ]]; then
+		eerror "Illegal hooks variable name: ${unsecure_varname}"
+		return 1
+	fi
+	
+	# hack: removes the beginning 'declare ... var=[quote]' and ending quote. Suggestions welcome.
+	declare -p "${varname}" | sed '1s|^[^=]*=['"'"'"]||; $s|['"'"'"]$||' > "${hooks_tmpdir}/${varname}" || return $?
+}
+
+# local variables listed here
+hook_files=( * )
+hook_args=( "$@" )
+hook_verbosity="0"
+local_vars=( "hook_files" "hook_args" "hook_verbosity" )
+
+for (( i = 0 ; i < ${#hook_args[@]} ; i++ )); do
+	if [[ "${hook_args[$i]}" == "--verbose" ]]; then
+		hook_verbosity="1"
+	fi
+done
+
+for (( i = 0 ; i < ${#hook_files[@]} ; i++ )); do
+	hook="${hook_files[$i]}"
+	
+	if [[ ! -f "${hook}" ]]; then
+		[ "${hook_verbosity}" -gt 0 ] && ewarn "Only files are recognized in a hook directory: ${hook}"
+		continue
+	fi
+	
+	[ "${hook_verbosity}" -gt 0 ] && einfo "Executing hook ${hook}..."
+	# We use eval so the hook_args gets expanded before it is unset
+	( eval unset "${local_vars[@]}" '&&' source "${hook}" "${hook_args[@]}" )
+	
+	exit_code="$?"
+	if [[ "${exit_code}" != "0" ]]; then
+		eerror "Hook returned with exit code ${exit_code}"
+		exit "${exit_code}"
+	fi
+done
+
+unset "${local_vars[@]}"
diff --git a/pym/portage/const.py b/pym/portage/const.py
index 33fffd1..dbe2a00 100644
--- a/pym/portage/const.py
+++ b/pym/portage/const.py
@@ -61,6 +61,7 @@ PORTAGE_PYM_PATH         = PORTAGE_BASE_PATH + "/pym"
 LOCALE_DATA_PATH         = PORTAGE_BASE_PATH + "/locale"  # FIXME: not used
 EBUILD_SH_BINARY         = PORTAGE_BIN_PATH + "/ebuild.sh"
 MISC_SH_BINARY           = PORTAGE_BIN_PATH + "/misc-functions.sh"
+HOOKS_SH_BINARY          = PORTAGE_BIN_PATH + "/hooks.sh"
 SANDBOX_BINARY           = "/usr/bin/sandbox"
 FAKEROOT_BINARY          = "/usr/bin/fakeroot"
 BASH_BINARY              = "/bin/bash"
diff --git a/pym/portage/hooks.py b/pym/portage/hooks.py
index ec4436d..2570067 100644
--- a/pym/portage/hooks.py
+++ b/pym/portage/hooks.py
@@ -2,7 +2,7 @@
 # Distributed under the terms of the GNU General Public License v2
 # $Id$
 
-from portage.const import BASH_BINARY, HOOKS_PATH, PORTAGE_BIN_PATH
+from portage.const import BASH_BINARY, HOOKS_PATH, HOOKS_SH_BINARY, PORTAGE_BIN_PATH
 from portage import os
 from portage import check_config_instance
 from portage import normalize_path
@@ -10,6 +10,8 @@ from portage.exception import PortageException
 from portage.exception import InvalidLocation
 from portage.output import EOutput
 from process import spawn
+from shutil import rmtree
+from tempfile import mkdtemp
 
 class HookDirectory(object):
 
@@ -34,36 +36,7 @@ class HookDirectory(object):
 			return
 		
 		if os.path.isdir(path):
-			for parent, dirs, files in os.walk(path):
-				for dir in dirs:
-					if self.myopts and "--debug" in self.myopts:
-						self.output.ewarn('Directory within hook directory not allowed; ignored: ' + path+'/'+dir)
-				for filename in files:
-					HookFile(os.path.join(path, filename), self.settings, self.myopts, self.myaction, self.mytargets).execute()
-		
-		else:
-			raise InvalidLocation('This hook path ought to be a directory: ' + path)
-
-class HookFile (object):
-	
-	def __init__ (self, path, settings, myopts=None, myaction=None, mytargets=None):
-		self.myopts = myopts
-		self.myaction = myaction
-		self.mytargets = mytargets
-		check_config_instance(settings)
-		self.path = normalize_path(path)
-		self.settings = settings
-		self.output = EOutput()
-	
-	def execute (self):
-		if "hooks" not in self.settings['FEATURES']:
-			return
-		
-		if not os.path.exists(self.path):
-			raise InvalidLocation('This hook path could not be found: ' + self.path)
-		
-		if os.path.isfile(self.path):
-			command=[self.path]
+			command=[HOOKS_SH_BINARY]
 			if self.myopts:
 				for myopt in self.myopts:
 					command.extend(['--opt', myopt])
@@ -73,12 +46,35 @@ class HookFile (object):
 				for mytarget in self.mytargets:
 					command.extend(['--target', mytarget])
 			
-			command=[BASH_BINARY, '-c', 'source ' + PORTAGE_BIN_PATH + '/isolated-functions.sh && source ' + ' '.join(command)]
-			if self.myopts and "--verbose" in self.myopts:
-				self.output.einfo('Executing hook "' + self.path + '"...')
-			code = spawn(mycommand=command, env=self.settings.environ())
-			if code: # if failure
-				raise PortageException('!!! Hook %s failed with exit code %s' % (self.path, code))
+			tmpdir = mkdtemp()
+			try:
+				command=[BASH_BINARY, '-c', 'cd "'+path+'" && source "' + PORTAGE_BIN_PATH + '/isolated-functions.sh" && declare -xr hooks_tmpdir="'+tmpdir+'" && source ' + ' '.join(command)]
+				if self.myopts and "--verbose" in self.myopts:
+					self.output.einfo('Executing hook "' + self.path + '"...')
+				code = spawn(mycommand=command, env=self.settings.environ())
+				if code: # if failure
+					raise PortageException('!!! Hook %s failed with exit code %s' % (self.path, code))
+					
+				self.settings = self.merge_to_env (self.settings, tmpdir)
+				
+			finally:
+				rmtree(tmpdir)
 		
 		else:
-			raise InvalidLocation('This hook path ought to be a file: ' + self.path)
+			raise InvalidLocation('This hook path ought to be a directory: ' + path)
+	
+	def merge_to_env (self, existingenv, path):
+		path = normalize_path(path)
+
+		if not os.path.isdir(path):
+			raise InvalidLocation('This environment path is not a directory: ' + path)
+		
+		for parent, dirs, files in os.walk(path):
+			for varname in files:
+				file = open(os.path.join(path, varname), 'r')
+				# read the file, remove the very last newline, and make the escaped double-quotes just plain double-quotes (since only bash needs them to be escaped, not python)
+				vardata = file.read()[:-1].replace('\"','"')
+				existingenv[varname] = vardata
+				existingenv.backup_changes(varname)
+		
+		return existingenv
diff --git a/pym/portage/tests/hooks/test_HookDirectory.py b/pym/portage/tests/hooks/test_HookDirectory.py
index d19c47b..3527e67 100644
--- a/pym/portage/tests/hooks/test_HookDirectory.py
+++ b/pym/portage/tests/hooks/test_HookDirectory.py
@@ -32,6 +32,7 @@ class HookDirectoryTestCase(TestCase):
 			settings["FEATURES"] += " hooks"
 			hooks = HookDirectory('test', settings)
 			hooks.execute()
+			self.assert_(settings["test"] == "this is a test")
 			self.assert_(file_len(tmp_dir_path+'/output') == 1)
 		finally:
 			rmtree(tmp_dir_path)
@@ -43,7 +44,8 @@ class HookDirectoryTestCase(TestCase):
 		
 		f = open(hooks_dir+'/testhook', 'w')
 		f.write('#!/bin/bash\n')
-		f.write('echo hi > '+tmp_dir+'/output && exit 0\n')
+		f.write('test="this is a test"\n')
+		f.write('echo hi > '+tmp_dir+'/output && hooksave test && exit 0\n')
 		f.close()
 		
 		return tmp_dir
-- 
1.6.4.4

